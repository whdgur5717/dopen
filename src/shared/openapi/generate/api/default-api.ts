/* tslint:disable */

/* eslint-disable */

/**
 * Social Network API
 * API for a social network service
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  type RequestArgs,
  RequiredError,
  operationServerMap,
} from '../base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from '../common';
import type { Configuration } from '../configuration';
// @ts-ignore
import type { Channel } from '../model';
// @ts-ignore
import type { Comment } from '../model';
// @ts-ignore
import type { Conversation } from '../model';
// @ts-ignore
import type { CreateChannelRequest } from '../model';
// @ts-ignore
import type { CreateCommentRequest } from '../model';
// @ts-ignore
import type { CreateNotificationRequest } from '../model';
// @ts-ignore
import type { Follow } from '../model';
// @ts-ignore
import type { FollowUserRequest } from '../model';
// @ts-ignore
import type { Like } from '../model';
// @ts-ignore
import type { LikePostRequest } from '../model';
// @ts-ignore
import type { Login200Response } from '../model';
// @ts-ignore
import type { LoginRequest } from '../model';
// @ts-ignore
import type { Message } from '../model';
// @ts-ignore
import type { Notification } from '../model';
// @ts-ignore
import type { Post } from '../model';
// @ts-ignore
import type { PutMessageSeenRequest } from '../model';
// @ts-ignore
import type { SearchPostAndUser200ResponseInner } from '../model';
// @ts-ignore
import type { SendMessageRequest } from '../model';
// @ts-ignore
import type { SignupRequest } from '../model';
// @ts-ignore
import type { UpdateUserInfoRequest } from '../model';
// @ts-ignore
import type { UpdateUserPasswordRequest } from '../model';
// @ts-ignore
import type { User } from '../model';

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Check authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserAuthentication: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Channel
     * @param {CreateChannelRequest} createChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChannel: async (
      createChannelRequest: CreateChannelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChannelRequest' is not null or undefined
      assertParamExists(
        'createChannel',
        'createChannelRequest',
        createChannelRequest,
      );
      const localVarPath = `/channels/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChannelRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a comment
     * @param {CreateCommentRequest} createCommentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment: async (
      createCommentRequest: CreateCommentRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createCommentRequest' is not null or undefined
      assertParamExists(
        'createComment',
        'createCommentRequest',
        createCommentRequest,
      );
      const localVarPath = `/comments/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createCommentRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a notification
     * @param {CreateNotificationRequest} createNotificationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotification: async (
      createNotificationRequest: CreateNotificationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createNotificationRequest' is not null or undefined
      assertParamExists(
        'createNotification',
        'createNotificationRequest',
        createNotificationRequest,
      );
      const localVarPath = `/notifications/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createNotificationRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a post
     * @param {string} title
     * @param {File | null} image
     * @param {string} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost: async (
      title: string,
      image: File | null,
      channelId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'title' is not null or undefined
      assertParamExists('createPost', 'title', title);
      // verify required parameter 'image' is not null or undefined
      assertParamExists('createPost', 'image', image);
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists('createPost', 'channelId', channelId);
      const localVarPath = `/posts/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (title !== undefined) {
        localVarFormParams.append('title', title as any);
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any);
      }

      if (channelId !== undefined) {
        localVarFormParams.append('channelId', channelId as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a comment
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteComment', 'id', id);
      const localVarPath = `/comments/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unlike a post
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLikePost: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteLikePost', 'id', id);
      const localVarPath = `/likes/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a post
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePost', 'id', id);
      const localVarPath = `/posts/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Follow a user
     * @param {FollowUserRequest} followUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser: async (
      followUserRequest: FollowUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'followUserRequest' is not null or undefined
      assertParamExists('followUser', 'followUserRequest', followUserRequest);
      const localVarPath = `/follow/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get channel information
     * @param {string} channelName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelInfo: async (
      channelName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelName' is not null or undefined
      assertParamExists('getChannelInfo', 'channelName', channelName);
      const localVarPath = `/channel/{channelName}`.replace(
        `{${'channelName'}}`,
        encodeURIComponent(String(channelName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get channel list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelList: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/channels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user\'s message inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageList: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/messages/conversations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get messages with a specific user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageListByUser: async (
      userId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getMessageListByUser', 'userId', userId);
      const localVarPath = `/messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotification: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/notifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get online users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOnlineUserList: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/online-users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get post details
     * @param {string} postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostByPostId: async (
      postId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postId' is not null or undefined
      assertParamExists('getPostByPostId', 'postId', postId);
      const localVarPath = `/posts/{postId}`.replace(
        `{${'postId'}}`,
        encodeURIComponent(String(postId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get posts for a specific channel
     * @param {string} channelId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostListByChannel: async (
      channelId: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists('getPostListByChannel', 'channelId', channelId);
      const localVarPath = `/posts/channel/{channelId}`.replace(
        `{${'channelId'}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get posts for a specific author
     * @param {string} authorId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostListByUser: async (
      authorId: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorId' is not null or undefined
      assertParamExists('getPostListByUser', 'authorId', authorId);
      const localVarPath = `/posts/author/{authorId}`.replace(
        `{${'authorId'}}`,
        encodeURIComponent(String(authorId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user information
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo: async (
      userId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUserInfo', 'userId', userId);
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user list
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList: async (
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/get-users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Like a post
     * @param {LikePostRequest} likePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likePost: async (
      likePostRequest: LikePostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'likePostRequest' is not null or undefined
      assertParamExists('likePost', 'likePostRequest', likePostRequest);
      const localVarPath = `/likes/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        likePostRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary User login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginRequest: LoginRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists('login', 'loginRequest', loginRequest);
      const localVarPath = `/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload profile or cover photo
     * @param {boolean} [isCover]
     * @param {File} [image]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserProfileImg: async (
      isCover?: boolean,
      image?: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/upload-photo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (isCover !== undefined) {
        localVarFormParams.append('isCover', String(isCover) as any);
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Mark messages as seen
     * @param {PutMessageSeenRequest} putMessageSeenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageSeen: async (
      putMessageSeenRequest: PutMessageSeenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'putMessageSeenRequest' is not null or undefined
      assertParamExists(
        'putMessageSeen',
        'putMessageSeenRequest',
        putMessageSeenRequest,
      );
      const localVarPath = `/messages/update-seen`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        putMessageSeenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Mark notifications as seen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putNotificationSeen: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/notifications/seen`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search posts and users
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchPostAndUser: async (
      query: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchPostAndUser', 'query', query);
      const localVarPath = `/search/all/{query}`.replace(
        `{${'query'}}`,
        encodeURIComponent(String(query)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search users
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUser: async (
      query: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchUser', 'query', query);
      const localVarPath = `/search/users/{query}`.replace(
        `{${'query'}}`,
        encodeURIComponent(String(query)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send a message
     * @param {SendMessageRequest} sendMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage: async (
      sendMessageRequest: SendMessageRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sendMessageRequest' is not null or undefined
      assertParamExists(
        'sendMessage',
        'sendMessageRequest',
        sendMessageRequest,
      );
      const localVarPath = `/messages/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sendMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary User registration
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      signupRequest: SignupRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'signupRequest' is not null or undefined
      assertParamExists('signup', 'signupRequest', signupRequest);
      const localVarPath = `/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signupRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unfollow a user
     * @param {FollowUserRequest} followUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser: async (
      followUserRequest: FollowUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'followUserRequest' is not null or undefined
      assertParamExists('unfollowUser', 'followUserRequest', followUserRequest);
      const localVarPath = `/follow/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a post
     * @param {string} [postId]
     * @param {string} [title]
     * @param {File} [image]
     * @param {string} [imageToDeletePublicId]
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost: async (
      postId?: string,
      title?: string,
      image?: File,
      imageToDeletePublicId?: string,
      channelId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/posts/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (postId !== undefined) {
        localVarFormParams.append('postId', postId as any);
      }

      if (title !== undefined) {
        localVarFormParams.append('title', title as any);
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any);
      }

      if (imageToDeletePublicId !== undefined) {
        localVarFormParams.append(
          'imageToDeletePublicId',
          imageToDeletePublicId as any,
        );
      }

      if (channelId !== undefined) {
        localVarFormParams.append('channelId', channelId as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user information
     * @param {UpdateUserInfoRequest} updateUserInfoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInfo: async (
      updateUserInfoRequest: UpdateUserInfoRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserInfoRequest' is not null or undefined
      assertParamExists(
        'updateUserInfo',
        'updateUserInfoRequest',
        updateUserInfoRequest,
      );
      const localVarPath = `/settings/update-user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserInfoRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update password
     * @param {UpdateUserPasswordRequest} updateUserPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword: async (
      updateUserPasswordRequest: UpdateUserPasswordRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserPasswordRequest' is not null or undefined
      assertParamExists(
        'updateUserPassword',
        'updateUserPasswordRequest',
        updateUserPasswordRequest,
      );
      const localVarPath = `/settings/update-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserPasswordRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Check authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkUserAuthentication(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<User>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkUserAuthentication(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.checkUserAuthentication']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create Channel
     * @param {CreateChannelRequest} createChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChannel(
      createChannelRequest: CreateChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Channel>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChannel(
        createChannelRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createChannel']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create a comment
     * @param {CreateCommentRequest} createCommentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createComment(
      createCommentRequest: CreateCommentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(
        createCommentRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createComment']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create a notification
     * @param {CreateNotificationRequest} createNotificationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNotification(
      createNotificationRequest: CreateNotificationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Notification>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createNotification(
          createNotificationRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createNotification']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create a post
     * @param {string} title
     * @param {File | null} image
     * @param {string} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPost(
      title: string,
      image: File | null,
      channelId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(
        title,
        image,
        channelId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createPost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a comment
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteComment(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.deleteComment']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Unlike a post
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLikePost(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Like>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLikePost(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.deleteLikePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a post
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePost(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.deletePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Follow a user
     * @param {FollowUserRequest} followUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async followUser(
      followUserRequest: FollowUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Follow>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(
        followUserRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.followUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get channel information
     * @param {string} channelName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelInfo(
      channelName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Channel>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelInfo(
        channelName,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getChannelInfo']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get channel list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelList(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Channel>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getChannelList(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getChannelList']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get user\'s message inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessageList(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Conversation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMessageList(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getMessageList']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get messages with a specific user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessageListByUser(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Message>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMessageListByUser(userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getMessageListByUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get user notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNotification(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Notification>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNotification(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getNotification']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get online users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOnlineUserList(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOnlineUserList(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getOnlineUserList']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get post details
     * @param {string} postId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostByPostId(
      postId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostByPostId(
        postId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPostByPostId']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get posts for a specific channel
     * @param {string} channelId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostListByChannel(
      channelId: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Post>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPostListByChannel(
          channelId,
          offset,
          limit,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPostListByChannel']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get posts for a specific author
     * @param {string} authorId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostListByUser(
      authorId: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<Post>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPostListByUser(
          authorId,
          offset,
          limit,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPostListByUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get user information
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfo(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUserInfo']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get user list
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserList(
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserList(
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getUserList']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Like a post
     * @param {LikePostRequest} likePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async likePost(
      likePostRequest: LikePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Like>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.likePost(
        likePostRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.likePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary User login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Login200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        loginRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.logout']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Upload profile or cover photo
     * @param {boolean} [isCover]
     * @param {File} [image]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserProfileImg(
      isCover?: boolean,
      image?: File,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<User>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postUserProfileImg(
          isCover,
          image,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.postUserProfileImg']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Mark messages as seen
     * @param {PutMessageSeenRequest} putMessageSeenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMessageSeen(
      putMessageSeenRequest: PutMessageSeenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putMessageSeen(
        putMessageSeenRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.putMessageSeen']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Mark notifications as seen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putNotificationSeen(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.putNotificationSeen(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.putNotificationSeen']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Search posts and users
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchPostAndUser(
      query: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<Array<SearchPostAndUser200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchPostAndUser(query, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.searchPostAndUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Search users
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchUser(
      query: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchUser(
        query,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.searchUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Send a message
     * @param {SendMessageRequest} sendMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendMessage(
      sendMessageRequest: SendMessageRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Message>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(
        sendMessageRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.sendMessage']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary User registration
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      signupRequest: SignupRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<Login200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
        signupRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.signup']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Unfollow a user
     * @param {FollowUserRequest} followUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfollowUser(
      followUserRequest: FollowUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Follow>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(
        followUserRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.unfollowUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a post
     * @param {string} [postId]
     * @param {string} [title]
     * @param {File} [image]
     * @param {string} [imageToDeletePublicId]
     * @param {string} [channelId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePost(
      postId?: string,
      title?: string,
      image?: File,
      imageToDeletePublicId?: string,
      channelId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(
        postId,
        title,
        image,
        imageToDeletePublicId,
        channelId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.updatePost']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update user information
     * @param {UpdateUserInfoRequest} updateUserInfoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserInfo(
      updateUserInfoRequest: UpdateUserInfoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInfo(
        updateUserInfoRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.updateUserInfo']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update password
     * @param {UpdateUserPasswordRequest} updateUserPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserPassword(
      updateUserPasswordRequest: UpdateUserPasswordRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateUserPassword(
          updateUserPasswordRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.updateUserPassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary Check authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserAuthentication(options?: RawAxiosRequestConfig): Promise<User> {
      return localVarFp
        .checkUserAuthentication(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create Channel
     * @param {DefaultApiCreateChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChannel(
      requestParameters: DefaultApiCreateChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Channel> {
      return localVarFp
        .createChannel(requestParameters.createChannelRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a comment
     * @param {DefaultApiCreateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createComment(
      requestParameters: DefaultApiCreateCommentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Comment> {
      return localVarFp
        .createComment(requestParameters.createCommentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a notification
     * @param {DefaultApiCreateNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotification(
      requestParameters: DefaultApiCreateNotificationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Notification> {
      return localVarFp
        .createNotification(
          requestParameters.createNotificationRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a post
     * @param {DefaultApiCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost(
      requestParameters: DefaultApiCreatePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Post> {
      return localVarFp
        .createPost(
          requestParameters.title,
          requestParameters.image,
          requestParameters.channelId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a comment
     * @param {DefaultApiDeleteCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(
      requestParameters: DefaultApiDeleteCommentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Comment> {
      return localVarFp
        .deleteComment(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unlike a post
     * @param {DefaultApiDeleteLikePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLikePost(
      requestParameters: DefaultApiDeleteLikePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Like> {
      return localVarFp
        .deleteLikePost(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a post
     * @param {DefaultApiDeletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost(
      requestParameters: DefaultApiDeletePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<void> {
      return localVarFp
        .deletePost(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Follow a user
     * @param {DefaultApiFollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser(
      requestParameters: DefaultApiFollowUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Follow> {
      return localVarFp
        .followUser(requestParameters.followUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get channel information
     * @param {DefaultApiGetChannelInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelInfo(
      requestParameters: DefaultApiGetChannelInfoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Channel> {
      return localVarFp
        .getChannelInfo(requestParameters.channelName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get channel list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelList(options?: RawAxiosRequestConfig): Promise<Array<Channel>> {
      return localVarFp
        .getChannelList(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user\'s message inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageList(
      options?: RawAxiosRequestConfig,
    ): Promise<Array<Conversation>> {
      return localVarFp
        .getMessageList(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get messages with a specific user
     * @param {DefaultApiGetMessageListByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageListByUser(
      requestParameters: DefaultApiGetMessageListByUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Array<Message>> {
      return localVarFp
        .getMessageListByUser(requestParameters.userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotification(
      options?: RawAxiosRequestConfig,
    ): Promise<Array<Notification>> {
      return localVarFp
        .getNotification(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get online users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOnlineUserList(options?: RawAxiosRequestConfig): Promise<Array<User>> {
      return localVarFp
        .getOnlineUserList(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get post details
     * @param {DefaultApiGetPostByPostIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostByPostId(
      requestParameters: DefaultApiGetPostByPostIdRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Post> {
      return localVarFp
        .getPostByPostId(requestParameters.postId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get posts for a specific channel
     * @param {DefaultApiGetPostListByChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostListByChannel(
      requestParameters: DefaultApiGetPostListByChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Array<Post>> {
      return localVarFp
        .getPostListByChannel(
          requestParameters.channelId,
          requestParameters.offset,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get posts for a specific author
     * @param {DefaultApiGetPostListByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostListByUser(
      requestParameters: DefaultApiGetPostListByUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Array<Post>> {
      return localVarFp
        .getPostListByUser(
          requestParameters.authorId,
          requestParameters.offset,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user information
     * @param {DefaultApiGetUserInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo(
      requestParameters: DefaultApiGetUserInfoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<User> {
      return localVarFp
        .getUserInfo(requestParameters.userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user list
     * @param {DefaultApiGetUserListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(
      requestParameters: DefaultApiGetUserListRequest = {},
      options?: RawAxiosRequestConfig,
    ): Promise<Array<User>> {
      return localVarFp
        .getUserList(requestParameters.offset, requestParameters.limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Like a post
     * @param {DefaultApiLikePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likePost(
      requestParameters: DefaultApiLikePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Like> {
      return localVarFp
        .likePost(requestParameters.likePostRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary User login
     * @param {DefaultApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      requestParameters: DefaultApiLoginRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Login200Response> {
      return localVarFp
        .login(requestParameters.loginRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): Promise<void> {
      return localVarFp
        .logout(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload profile or cover photo
     * @param {DefaultApiPostUserProfileImgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserProfileImg(
      requestParameters: DefaultApiPostUserProfileImgRequest = {},
      options?: RawAxiosRequestConfig,
    ): Promise<User> {
      return localVarFp
        .postUserProfileImg(
          requestParameters.isCover,
          requestParameters.image,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Mark messages as seen
     * @param {DefaultApiPutMessageSeenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageSeen(
      requestParameters: DefaultApiPutMessageSeenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<void> {
      return localVarFp
        .putMessageSeen(requestParameters.putMessageSeenRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Mark notifications as seen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putNotificationSeen(options?: RawAxiosRequestConfig): Promise<void> {
      return localVarFp
        .putNotificationSeen(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search posts and users
     * @param {DefaultApiSearchPostAndUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchPostAndUser(
      requestParameters: DefaultApiSearchPostAndUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Array<SearchPostAndUser200ResponseInner>> {
      return localVarFp
        .searchPostAndUser(requestParameters.query, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search users
     * @param {DefaultApiSearchUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUser(
      requestParameters: DefaultApiSearchUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Array<User>> {
      return localVarFp
        .searchUser(requestParameters.query, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send a message
     * @param {DefaultApiSendMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessage(
      requestParameters: DefaultApiSendMessageRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Message> {
      return localVarFp
        .sendMessage(requestParameters.sendMessageRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary User registration
     * @param {DefaultApiSignupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(
      requestParameters: DefaultApiSignupRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Login200Response> {
      return localVarFp
        .signup(requestParameters.signupRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unfollow a user
     * @param {DefaultApiUnfollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser(
      requestParameters: DefaultApiUnfollowUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<Follow> {
      return localVarFp
        .unfollowUser(requestParameters.followUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a post
     * @param {DefaultApiUpdatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost(
      requestParameters: DefaultApiUpdatePostRequest = {},
      options?: RawAxiosRequestConfig,
    ): Promise<Post> {
      return localVarFp
        .updatePost(
          requestParameters.postId,
          requestParameters.title,
          requestParameters.image,
          requestParameters.imageToDeletePublicId,
          requestParameters.channelId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update user information
     * @param {DefaultApiUpdateUserInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInfo(
      requestParameters: DefaultApiUpdateUserInfoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<User> {
      return localVarFp
        .updateUserInfo(requestParameters.updateUserInfoRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update password
     * @param {DefaultApiUpdateUserPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserPassword(
      requestParameters: DefaultApiUpdateUserPasswordRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<void> {
      return localVarFp
        .updateUserPassword(
          requestParameters.updateUserPasswordRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createChannel operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateChannelRequest
 */
export interface DefaultApiCreateChannelRequest {
  /**
   *
   * @type {CreateChannelRequest}
   * @memberof DefaultApiCreateChannel
   */
  readonly createChannelRequest: CreateChannelRequest;
}

/**
 * Request parameters for createComment operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateCommentRequest
 */
export interface DefaultApiCreateCommentRequest {
  /**
   *
   * @type {CreateCommentRequest}
   * @memberof DefaultApiCreateComment
   */
  readonly createCommentRequest: CreateCommentRequest;
}

/**
 * Request parameters for createNotification operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateNotificationRequest
 */
export interface DefaultApiCreateNotificationRequest {
  /**
   *
   * @type {CreateNotificationRequest}
   * @memberof DefaultApiCreateNotification
   */
  readonly createNotificationRequest: CreateNotificationRequest;
}

/**
 * Request parameters for createPost operation in DefaultApi.
 * @export
 * @interface DefaultApiCreatePostRequest
 */
export interface DefaultApiCreatePostRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiCreatePost
   */
  readonly title: string;

  /**
   *
   * @type {File}
   * @memberof DefaultApiCreatePost
   */
  readonly image: File | null;

  /**
   *
   * @type {string}
   * @memberof DefaultApiCreatePost
   */
  readonly channelId: string;
}

/**
 * Request parameters for deleteComment operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteCommentRequest
 */
export interface DefaultApiDeleteCommentRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiDeleteComment
   */
  readonly id: string;
}

/**
 * Request parameters for deleteLikePost operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteLikePostRequest
 */
export interface DefaultApiDeleteLikePostRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiDeleteLikePost
   */
  readonly id: string;
}

/**
 * Request parameters for deletePost operation in DefaultApi.
 * @export
 * @interface DefaultApiDeletePostRequest
 */
export interface DefaultApiDeletePostRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiDeletePost
   */
  readonly id: string;
}

/**
 * Request parameters for followUser operation in DefaultApi.
 * @export
 * @interface DefaultApiFollowUserRequest
 */
export interface DefaultApiFollowUserRequest {
  /**
   *
   * @type {FollowUserRequest}
   * @memberof DefaultApiFollowUser
   */
  readonly followUserRequest: FollowUserRequest;
}

/**
 * Request parameters for getChannelInfo operation in DefaultApi.
 * @export
 * @interface DefaultApiGetChannelInfoRequest
 */
export interface DefaultApiGetChannelInfoRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetChannelInfo
   */
  readonly channelName: string;
}

/**
 * Request parameters for getMessageListByUser operation in DefaultApi.
 * @export
 * @interface DefaultApiGetMessageListByUserRequest
 */
export interface DefaultApiGetMessageListByUserRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetMessageListByUser
   */
  readonly userId: string;
}

/**
 * Request parameters for getPostByPostId operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPostByPostIdRequest
 */
export interface DefaultApiGetPostByPostIdRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetPostByPostId
   */
  readonly postId: string;
}

/**
 * Request parameters for getPostListByChannel operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPostListByChannelRequest
 */
export interface DefaultApiGetPostListByChannelRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetPostListByChannel
   */
  readonly channelId: string;

  /**
   *
   * @type {number}
   * @memberof DefaultApiGetPostListByChannel
   */
  readonly offset?: number;

  /**
   *
   * @type {number}
   * @memberof DefaultApiGetPostListByChannel
   */
  readonly limit?: number;
}

/**
 * Request parameters for getPostListByUser operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPostListByUserRequest
 */
export interface DefaultApiGetPostListByUserRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetPostListByUser
   */
  readonly authorId: string;

  /**
   *
   * @type {number}
   * @memberof DefaultApiGetPostListByUser
   */
  readonly offset?: number;

  /**
   *
   * @type {number}
   * @memberof DefaultApiGetPostListByUser
   */
  readonly limit?: number;
}

/**
 * Request parameters for getUserInfo operation in DefaultApi.
 * @export
 * @interface DefaultApiGetUserInfoRequest
 */
export interface DefaultApiGetUserInfoRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiGetUserInfo
   */
  readonly userId: string;
}

/**
 * Request parameters for getUserList operation in DefaultApi.
 * @export
 * @interface DefaultApiGetUserListRequest
 */
export interface DefaultApiGetUserListRequest {
  /**
   *
   * @type {number}
   * @memberof DefaultApiGetUserList
   */
  readonly offset?: number;

  /**
   *
   * @type {number}
   * @memberof DefaultApiGetUserList
   */
  readonly limit?: number;
}

/**
 * Request parameters for likePost operation in DefaultApi.
 * @export
 * @interface DefaultApiLikePostRequest
 */
export interface DefaultApiLikePostRequest {
  /**
   *
   * @type {LikePostRequest}
   * @memberof DefaultApiLikePost
   */
  readonly likePostRequest: LikePostRequest;
}

/**
 * Request parameters for login operation in DefaultApi.
 * @export
 * @interface DefaultApiLoginRequest
 */
export interface DefaultApiLoginRequest {
  /**
   *
   * @type {LoginRequest}
   * @memberof DefaultApiLogin
   */
  readonly loginRequest: LoginRequest;
}

/**
 * Request parameters for postUserProfileImg operation in DefaultApi.
 * @export
 * @interface DefaultApiPostUserProfileImgRequest
 */
export interface DefaultApiPostUserProfileImgRequest {
  /**
   *
   * @type {boolean}
   * @memberof DefaultApiPostUserProfileImg
   */
  readonly isCover?: boolean;

  /**
   *
   * @type {File}
   * @memberof DefaultApiPostUserProfileImg
   */
  readonly image?: File;
}

/**
 * Request parameters for putMessageSeen operation in DefaultApi.
 * @export
 * @interface DefaultApiPutMessageSeenRequest
 */
export interface DefaultApiPutMessageSeenRequest {
  /**
   *
   * @type {PutMessageSeenRequest}
   * @memberof DefaultApiPutMessageSeen
   */
  readonly putMessageSeenRequest: PutMessageSeenRequest;
}

/**
 * Request parameters for searchPostAndUser operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchPostAndUserRequest
 */
export interface DefaultApiSearchPostAndUserRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiSearchPostAndUser
   */
  readonly query: string;
}

/**
 * Request parameters for searchUser operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchUserRequest
 */
export interface DefaultApiSearchUserRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiSearchUser
   */
  readonly query: string;
}

/**
 * Request parameters for sendMessage operation in DefaultApi.
 * @export
 * @interface DefaultApiSendMessageRequest
 */
export interface DefaultApiSendMessageRequest {
  /**
   *
   * @type {SendMessageRequest}
   * @memberof DefaultApiSendMessage
   */
  readonly sendMessageRequest: SendMessageRequest;
}

/**
 * Request parameters for signup operation in DefaultApi.
 * @export
 * @interface DefaultApiSignupRequest
 */
export interface DefaultApiSignupRequest {
  /**
   *
   * @type {SignupRequest}
   * @memberof DefaultApiSignup
   */
  readonly signupRequest: SignupRequest;
}

/**
 * Request parameters for unfollowUser operation in DefaultApi.
 * @export
 * @interface DefaultApiUnfollowUserRequest
 */
export interface DefaultApiUnfollowUserRequest {
  /**
   *
   * @type {FollowUserRequest}
   * @memberof DefaultApiUnfollowUser
   */
  readonly followUserRequest: FollowUserRequest;
}

/**
 * Request parameters for updatePost operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdatePostRequest
 */
export interface DefaultApiUpdatePostRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiUpdatePost
   */
  readonly postId?: string;

  /**
   *
   * @type {string}
   * @memberof DefaultApiUpdatePost
   */
  readonly title?: string;

  /**
   *
   * @type {File}
   * @memberof DefaultApiUpdatePost
   */
  readonly image?: File;

  /**
   *
   * @type {string}
   * @memberof DefaultApiUpdatePost
   */
  readonly imageToDeletePublicId?: string;

  /**
   *
   * @type {string}
   * @memberof DefaultApiUpdatePost
   */
  readonly channelId?: string;
}

/**
 * Request parameters for updateUserInfo operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdateUserInfoRequest
 */
export interface DefaultApiUpdateUserInfoRequest {
  /**
   *
   * @type {UpdateUserInfoRequest}
   * @memberof DefaultApiUpdateUserInfo
   */
  readonly updateUserInfoRequest: UpdateUserInfoRequest;
}

/**
 * Request parameters for updateUserPassword operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdateUserPasswordRequest
 */
export interface DefaultApiUpdateUserPasswordRequest {
  /**
   *
   * @type {UpdateUserPasswordRequest}
   * @memberof DefaultApiUpdateUserPassword
   */
  readonly updateUserPasswordRequest: UpdateUserPasswordRequest;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary Check authentication
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public checkUserAuthentication(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .checkUserAuthentication(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create Channel
   * @param {DefaultApiCreateChannelRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChannel(
    requestParameters: DefaultApiCreateChannelRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createChannel(requestParameters.createChannelRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a comment
   * @param {DefaultApiCreateCommentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createComment(
    requestParameters: DefaultApiCreateCommentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createComment(requestParameters.createCommentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a notification
   * @param {DefaultApiCreateNotificationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createNotification(
    requestParameters: DefaultApiCreateNotificationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createNotification(requestParameters.createNotificationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a post
   * @param {DefaultApiCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPost(
    requestParameters: DefaultApiCreatePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createPost(
        requestParameters.title,
        requestParameters.image,
        requestParameters.channelId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a comment
   * @param {DefaultApiDeleteCommentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteComment(
    requestParameters: DefaultApiDeleteCommentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteComment(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unlike a post
   * @param {DefaultApiDeleteLikePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteLikePost(
    requestParameters: DefaultApiDeleteLikePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteLikePost(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a post
   * @param {DefaultApiDeletePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deletePost(
    requestParameters: DefaultApiDeletePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deletePost(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Follow a user
   * @param {DefaultApiFollowUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public followUser(
    requestParameters: DefaultApiFollowUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .followUser(requestParameters.followUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get channel information
   * @param {DefaultApiGetChannelInfoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChannelInfo(
    requestParameters: DefaultApiGetChannelInfoRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getChannelInfo(requestParameters.channelName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get channel list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChannelList(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getChannelList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user\'s message inbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMessageList(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMessageList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get messages with a specific user
   * @param {DefaultApiGetMessageListByUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMessageListByUser(
    requestParameters: DefaultApiGetMessageListByUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getMessageListByUser(requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user notifications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getNotification(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getNotification(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get online users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getOnlineUserList(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getOnlineUserList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get post details
   * @param {DefaultApiGetPostByPostIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostByPostId(
    requestParameters: DefaultApiGetPostByPostIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostByPostId(requestParameters.postId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get posts for a specific channel
   * @param {DefaultApiGetPostListByChannelRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostListByChannel(
    requestParameters: DefaultApiGetPostListByChannelRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostListByChannel(
        requestParameters.channelId,
        requestParameters.offset,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get posts for a specific author
   * @param {DefaultApiGetPostListByUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostListByUser(
    requestParameters: DefaultApiGetPostListByUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostListByUser(
        requestParameters.authorId,
        requestParameters.offset,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user information
   * @param {DefaultApiGetUserInfoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserInfo(
    requestParameters: DefaultApiGetUserInfoRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getUserInfo(requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user list
   * @param {DefaultApiGetUserListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserList(
    requestParameters: DefaultApiGetUserListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getUserList(requestParameters.offset, requestParameters.limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Like a post
   * @param {DefaultApiLikePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public likePost(
    requestParameters: DefaultApiLikePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .likePost(requestParameters.likePostRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary User login
   * @param {DefaultApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public login(
    requestParameters: DefaultApiLoginRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .login(requestParameters.loginRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary User logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload profile or cover photo
   * @param {DefaultApiPostUserProfileImgRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public postUserProfileImg(
    requestParameters: DefaultApiPostUserProfileImgRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .postUserProfileImg(
        requestParameters.isCover,
        requestParameters.image,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Mark messages as seen
   * @param {DefaultApiPutMessageSeenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putMessageSeen(
    requestParameters: DefaultApiPutMessageSeenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .putMessageSeen(requestParameters.putMessageSeenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Mark notifications as seen
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putNotificationSeen(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .putNotificationSeen(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search posts and users
   * @param {DefaultApiSearchPostAndUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchPostAndUser(
    requestParameters: DefaultApiSearchPostAndUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .searchPostAndUser(requestParameters.query, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search users
   * @param {DefaultApiSearchUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchUser(
    requestParameters: DefaultApiSearchUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .searchUser(requestParameters.query, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send a message
   * @param {DefaultApiSendMessageRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sendMessage(
    requestParameters: DefaultApiSendMessageRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .sendMessage(requestParameters.sendMessageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary User registration
   * @param {DefaultApiSignupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public signup(
    requestParameters: DefaultApiSignupRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .signup(requestParameters.signupRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unfollow a user
   * @param {DefaultApiUnfollowUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unfollowUser(
    requestParameters: DefaultApiUnfollowUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .unfollowUser(requestParameters.followUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a post
   * @param {DefaultApiUpdatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePost(
    requestParameters: DefaultApiUpdatePostRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updatePost(
        requestParameters.postId,
        requestParameters.title,
        requestParameters.image,
        requestParameters.imageToDeletePublicId,
        requestParameters.channelId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user information
   * @param {DefaultApiUpdateUserInfoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserInfo(
    requestParameters: DefaultApiUpdateUserInfoRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateUserInfo(requestParameters.updateUserInfoRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update password
   * @param {DefaultApiUpdateUserPasswordRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserPassword(
    requestParameters: DefaultApiUpdateUserPasswordRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateUserPassword(requestParameters.updateUserPasswordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
